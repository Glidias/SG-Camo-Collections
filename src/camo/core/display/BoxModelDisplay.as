/**  * <p>Original Author:  jessefreeman</p> * <p>Class File: BoxModelDisplay.as</p> *  * <p>Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions:</p> *  * <p>The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software.</p> *  * <p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE.</p> *  * <p>Licensed under The MIT License</p> * <p>Redistributions of files must retain the above copyright notice.</p> * * <p>Revisions<br/>  * 	2.0  Initial version Jan 7, 2009</p> *  *  *  Changes made on Sept 05, 2009 - Glenn (commented) *  * - Removed off static TypeHelperUtil reference * - Removed static CSS class enum property lookups and resorted to inlining * */package camo.core.display {	import flash.geom.ColorTransform;	import flash.geom.Point;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.events.Event;	import flash.geom.Matrix;	import flash.geom.Rectangle;	/**	 * @author jessefreeman	 * 	 * @author glenn  (changes commented)	 */	public class BoxModelDisplay extends AbstractDisplay implements IBoxModel 	{		public static const BACKGROUND_IMAGE_COMPLETE : String = "backgroundImageComplete";		protected static const DELIMITER : String = " ";		protected var _backgroundImageBitmap : Bitmap;		protected var _backgroundImageCache:BitmapData;		protected var _paddingRectangle : Rectangle = new Rectangle( );		protected var _borderRectangle : Rectangle = new Rectangle( );		protected var _backgroundColor : Number;		protected var _borderColor : Number;		protected var _backgroundScale9Grid : Rectangle;		protected var _backgroundRepeat : String;		protected var _bitmapSmoothing:Boolean = false;			protected var _backgroundColorAlpha : Number;		protected var _paddingTop : Number = 0;		protected var _paddingRight : Number = 0;		protected var _paddingBottom : Number = 0;		protected var _paddingLeft : Number = 0;		protected var _marginTop : Number = 0;		protected var _marginRight : Number = 0;		protected var _marginBottom : Number = 0;		protected var _marginLeft : Number = 0;		protected var _borderTop : Number = 0;		protected var _borderRight : Number = 0;		protected var _borderBottom : Number = 0;		protected var _borderLeft : Number = 0;		protected var _borderProperties : String;		protected var _borderAlpha : Number = 1;		protected var _backgroundPositionX : Number = 0;		protected var _backgroundPositionY : Number = 0;		protected var _backgroundImageAlpha : Number = 1;				// added some pre-cached backgroundImage states/instances		protected var _backgroundImageChanged:Boolean = true;		protected var _backgroundImageColorTransform:ColorTransform  = new ColorTransform(1, 1, 1, 1);		protected var _bgImageMatrix:Matrix = new Matrix();		/*		protected var _debugPadding : Boolean = false;		protected var _debugPaddingColor : uint = 0xFFFF00;*/				override public function destroy():void {			super.destroy();			if (_backgroundImageBitmap && _backgroundImageBitmap.bitmapData)  _backgroundImageBitmap.bitmapData.dispose();			if (_backgroundImageCache) _backgroundImageCache.dispose();			_backgroundImageBitmap = null;			_backgroundImageCache = null;		}				public function set backgroundColor(value : uint) : void		{			_backgroundColor = value;			invalidate( );			}				public function get backgroundColor():uint		{			return _backgroundColor; 		}				public function set borderColor(value : uint) : void		{			_borderColor = value;			invalidate( );			}		public function get borderColor():uint {			return _borderColor;		}		public function set backgroundPosition(value : String) : void		{			var split : Array = value.split( " ", 2 );			backgroundPositionX = Number( split[0] );			backgroundPositionY = Number( split[1] );			invalidate( );		}		public function set padding(values : Array) : void		{			values = validateOffset( values );			paddingTop = values[0];			paddingRight = values[1];			paddingBottom = values[2];			paddingLeft = values[3];			invalidate( );		}		public function get padding() : Array		{			return [ paddingTop, paddingRight, paddingBottom, paddingLeft ];			}		public function set margin(values : Array) : void		{			values = validateOffset( values );			marginTop = values[0];			marginRight = values[1];			marginBottom = values[2];			marginLeft = values[3];			invalidate( );		}		public function get margin() : Array		{			return [ marginTop, marginRight, marginBottom, marginLeft ];			}		override public function get width() : Number		{			var tempWidth : Number = display.width > _width ? display.width : _width;			return borderLeft + paddingLeft + tempWidth + paddingRight + borderRight;		}				override public function get height() : Number		{			var tempHeight : Number = (display.height > _height) ? display.height : _height;			return borderTop + paddingTop + tempHeight + paddingBottom + borderBottom;		}				/*		override public function get __width():Number {			return display.width > _width ? display.width : _width;		}				override public function get __height():Number {			return display.height > _height ? display.height : _height;		}		*/			public function set border(value : String) : void		{			var values : Array = value.split( DELIMITER, 4 );						borderTop = borderRight = borderBottom = borderLeft = values[0];			borderProperties = values[1];			_borderColor = stringToUint( values[2] );			borderAlpha = Number( values[3] );			invalidate( );		}						private static function stringToUint(value : String) : uint		{			value = value.substr( - 6, 6 );			var color : uint = Number( "0x" + value );			return color;		}			public function get hasBorder() : Boolean		{			var value : Number = borderTop + borderRight + borderBottom + borderLeft;			return Boolean( value );		}		override public function get displayWidth() : Number		{			return (display.width > _width) ? display.width : _width;		}			override public function get displayHeight() : Number		{			return (display.height > _height) ? display.height : _height;		}		public function get backgroundScale9Grid() : Rectangle		{			return _backgroundScale9Grid;		}		public function set backgroundScale9Grid(backgroundScale9Grid : Rectangle) : void		{			_backgroundScale9Grid = backgroundScale9Grid;			invalidate( );		}		public function get backgroundRepeat() : String		{			return _backgroundRepeat;		}		public function set backgroundRepeat(backgroundRepeat : String) : void		{			_backgroundRepeat = backgroundRepeat;			invalidate( );		}		public function get backgroundColorAlpha() : Number		{			return _backgroundColorAlpha;		}		public function set backgroundColorAlpha(backgroundColorAlpha : Number) : void		{			_backgroundColorAlpha = backgroundColorAlpha;			invalidate( );		}		public function get paddingTop() : Number		{			return _paddingTop;		}		public function set paddingTop(paddingTop : Number) : void		{			_bubblingDraw = true;			_paddingTop = paddingTop;			invalidate( );		}		public function get paddingRight() : Number		{			return _paddingRight;		}		public function set paddingRight(paddingRight : Number) : void		{			_bubblingDraw = true;			_paddingRight = paddingRight;			invalidate( );		}		public function get paddingBottom() : Number		{			return _paddingBottom;		}		public function set paddingBottom(paddingBottom : Number) : void		{			_bubblingDraw = true;			_paddingBottom = paddingBottom;			invalidate( );		}		public function get paddingLeft() : Number		{			return _paddingLeft;		}		public function set paddingLeft(paddingLeft : Number) : void		{			_bubblingDraw = true;			_paddingLeft = paddingLeft;			invalidate( );		}		public function get marginTop() : Number		{			return _marginTop;		}		public function set marginTop(marginTop : Number) : void		{			_marginTop = marginTop;			invalidate( );		}		public function get marginRight() : Number		{			return _marginRight;		}		public function set marginRight(marginRight : Number) : void		{			_marginRight = marginRight;			invalidate( );		}		public function get marginBottom() : Number		{			return _marginBottom;		}		public function set marginBottom(marginBottom : Number) : void		{			_marginBottom = marginBottom;			invalidate( );		}		public function get marginLeft() : Number		{			return _marginLeft;		}		public function set marginLeft(marginLeft : Number) : void		{			_marginLeft = marginLeft;			invalidate( );		}				public function set borderThickness(val:Number):void {			_borderTop = val;			_borderBottom = val;			_borderLeft = val;			_borderRight = val;		}		public function get borderTop() : Number		{			return _borderTop;		}		public function set borderTop(borderTop : Number) : void		{			_borderTop = borderTop;			invalidate( );		}		public function get borderRight() : Number		{			return _borderRight;		}		public function set borderRight(borderRight : Number) : void		{			_borderRight = borderRight;			invalidate( );		}		public function get borderBottom() : Number		{			return _borderBottom;		}		public function set borderBottom(borderBottom : Number) : void		{			_borderBottom = borderBottom;			invalidate( );		}		public function get borderLeft() : Number		{			return _borderLeft;		}		public function set borderLeft(borderLeft : Number) : void		{			_borderLeft = borderLeft;			invalidate( );		}		public function get borderProperties() : String		{			return _borderProperties;		}		public function set borderProperties(borderProperties : String) : void		{			_borderProperties = borderProperties;			invalidate( );		}		public function get borderAlpha() : Number		{			return _borderAlpha;		}		public function set borderAlpha(borderAlpha : Number) : void		{			_borderAlpha = borderAlpha;			invalidate( );		}		public function get backgroundPositionX() : Number		{			return _backgroundPositionX;		}		public function set backgroundPositionX(backgroundPositionX : Number) : void		{			_backgroundPositionX = backgroundPositionX;			invalidate( );		}		public function get backgroundPositionY() : Number		{			return _backgroundPositionY;		}		public function set backgroundPositionY(backgroundPositionY : Number) : void		{			_backgroundPositionY = backgroundPositionY;			invalidate( );		}		/*		public function get debugPadding() : Boolean		{			return _debugPadding;		}		public function set debugPadding(debugPadding : Boolean) : void		{			_debugPadding = debugPadding;			invalidate( );		}		public function get debugPaddingColor() : uint		{			return _debugPaddingColor;		}		public function set debugPaddingColor(debugPaddingColor : uint) : void		{			_debugPaddingColor = debugPaddingColor;			invalidate( );		}*/		public function get backgroundImageBitmap() : Bitmap		{			return _backgroundImageBitmap;		}		/**		 * Sets background image bitmap directly to use as a bitmapData source.		 * <b>Important note:</b>Make sure you (or a data provider) provides a cloned instance of 		 * the bitmap's bitmapData to prevent the bitmapData from being disposed by the component.		 */		public function set backgroundImageBitmap(backgroundImageBitmap : Bitmap) : void		{			if (_backgroundImageCache) {				_backgroundImageCache.dispose();				_backgroundImageCache = null;			}				_backgroundImageBitmap = backgroundImageBitmap;			_backgroundImageChanged = true;			invalidate ( );		}		public function get backgroundImageAlpha() : Number		{			return _backgroundImageAlpha;		}		public function set backgroundImageAlpha(backgroundImageAlpha : Number) : void		{			_backgroundImageAlpha = backgroundImageAlpha;			_backgroundImageChanged = true;			invalidate( );		}				public function get bitmapSmoothing():Boolean { return _bitmapSmoothing; }				public function set bitmapSmoothing(value:Boolean):void 		{			_bitmapSmoothing = value;			invalidate();		}			public function BoxModelDisplay() 		{			super( this );		}			override public function getBounds(targetCoordinateSpace : DisplayObject) : Rectangle		{			var bounds : Rectangle = super.getBounds( targetCoordinateSpace ).clone( );			bounds.width = width;			bounds.height = height;			return bounds;		}		override public function getRect(targetCoordinateSpace : DisplayObject) : Rectangle		{			var rect : Rectangle = super.getRect( targetCoordinateSpace ).clone( );			rect.width = width;			rect.height = height;			return rect;		}			protected function sampleBackground(tempBitmap : Bitmap) : void		{			var srcW : Number = tempBitmap.width;			var srcH : Number = tempBitmap.height;						//var bmd : BitmapData = new BitmapData( srcW, srcH, true, 0x00FFFFFF );			//bmd.draw( tempBitmap );  // isn';t draw rather too heavy?						if (_backgroundImageCache) {				_backgroundImageCache.dispose();				_backgroundImageCache = null;			}						_backgroundImageBitmap = tempBitmap;			//createBackgroundBitmap( bmd );						if(backgroundScale9Grid) 			{				_backgroundImageBitmap.scale9Grid = backgroundScale9Grid;			}						dispatchEvent( new Event( BACKGROUND_IMAGE_COMPLETE, true, true ) );			invalidate( );		}		protected function createBackgroundBitmap(bitmapData : BitmapData) : Bitmap		{			return new Bitmap( bitmapData );		}			override protected function draw() : void		{			calculatePadding( );						calculateBorder( );						// Start drawing			graphics.clear( );						// Create Border			if(hasBorder)			{				drawBorder( );			}						if(! isNaN( _backgroundColor ))			{				drawBackgroundColor( );			}						drawBackgroundImage( );									graphics.endFill( );						// Align Content			alignDisplay( );						super.draw( );			 		}				protected function calculatePadding() : void		{			// Take content w,h + padding to calculate padding size			_paddingRectangle.width = paddingLeft + displayWidth + paddingRight;			_paddingRectangle.height = paddingTop + displayHeight + paddingBottom;			_paddingRectangle.x = borderLeft;			_paddingRectangle.y = borderTop;		}			protected function calculateBorder() : void		{			_borderRectangle.width = _paddingRectangle.width + borderLeft + borderRight;			_borderRectangle.height = _paddingRectangle.height + borderTop + borderBottom;		}			protected function drawBorder() : void		{			graphics.beginFill( _borderColor, borderAlpha );			graphics.drawRect( _borderRectangle.x, _borderRectangle.y, _borderRectangle.width, _borderRectangle.height );			graphics.drawRect( borderLeft, borderTop, _paddingRectangle.width, _paddingRectangle.height );		}			protected function drawBackgroundImage() : void		{			if(_backgroundImageBitmap)			{				var bgiFullW : Number = paddingLeft + displayWidth + paddingRight;				var bgiFullH : Number = paddingTop + displayHeight + paddingBottom;								var bgiW : Number = _backgroundImageBitmap.width;				var bgiH : Number = _backgroundImageBitmap.height;								var bgX : Number = _paddingRectangle.x;				var bgY : Number = _paddingRectangle.y;								var m : Matrix = _bgImageMatrix;				m.identity();								var bmd : BitmapData = _backgroundImageCache || (_backgroundImageCache = new BitmapData(bgiW, bgiH, true,0xFFFF0000));				switch (backgroundRepeat)				{					case "no-repeat":						bgX = backgroundPositionX+borderLeft;						bgY = backgroundPositionY+borderTop;						m.translate( bgX, bgY );						break;					case "repeat-x":						bgiW = bgiFullW;						m.translate( borderLeft, borderTop );						break;					case "repeat-y":						bgiH = bgiFullH;						m.translate( borderLeft, borderTop );													break;					default:						bgiW = bgiFullW;						bgiH = bgiFullH;						m.translate( borderLeft, borderTop );						break;				}								if (_backgroundImageChanged) {					bmd.fillRect(bmd.rect, 0);					_backgroundImageColorTransform.alphaMultiplier = _backgroundImageAlpha;					bmd.draw( _backgroundImageBitmap, null, _backgroundImageColorTransform  );					_backgroundImageChanged = false;				}								m.identity();				m.translate(_backgroundPositionX, _backgroundPositionY);  								graphics.beginBitmapFill( bmd, m, _backgroundRepeat!="no-repeat", _bitmapSmoothing);				graphics.drawRect( bgX, bgY, bgiW, bgiH );				graphics.endFill( );			}		}			protected function drawBackgroundColor() : void		{			backgroundColorAlpha = isNaN( backgroundColorAlpha ) ? 1 : backgroundColorAlpha;						var tempColor: uint = _backgroundColor; // _debugPadding ? _debugPaddingColor : 						graphics.beginFill( tempColor, backgroundColorAlpha );			graphics.drawRect( _paddingRectangle.x, _paddingRectangle.y, _paddingRectangle.width, _paddingRectangle.height );			graphics.endFill( );						/*			if(_debugPadding)			{				graphics.beginFill( _backgroundColor, backgroundColorAlpha );				graphics.drawRect( display.x, display.y, displayWidth, displayHeight );				graphics.endFill( );			}*/		}			protected function alignDisplay() : void		{			display.x = paddingLeft + borderLeft;			display.y = paddingTop + borderTop;		}			protected function resetBackgroundPosition() : void		{			backgroundPositionX = backgroundPositionY = 0;		}				public function clearProperties() : void		{			clearPadding( );			clearMargin( );			clearBorder( );			clearBackground( );		}			public function clearPadding() : void		{			padding = [ 0,0,0,0 ];		}			public function clearMargin() : void		{			margin = [ 0, 0, 0, 0 ];		}			public function clearBorder() : void		{			borderAlpha = 1;			borderLeft = borderRight = borderBottom = borderLeft = 0;			_borderColor = NaN;					}			public function clearBackground() : void		{			_backgroundImageBitmap = null;			_backgroundColor = NaN;			backgroundColorAlpha = NaN;		}				protected function validateOffset(values : Array) : Array 		{						var total : Number = values.length;			var offset : Array;						if(total == 1)			{				var baseValue : Number = values[0];				offset = [ baseValue, baseValue, baseValue, baseValue ];			}			else if (total == 2)			{				var tbValue : Number = values[0];				var lrValue : Number = values[1];				offset = [ tbValue, lrValue, tbValue, lrValue ];			}			else			{				for (var i : Number = 0; i < 4 ; i ++)				{					if (! values[i]) values[i] = 0; 				}				offset = [ values[0], values[1], values[2], values[3] ];			}						return offset;		}	}}